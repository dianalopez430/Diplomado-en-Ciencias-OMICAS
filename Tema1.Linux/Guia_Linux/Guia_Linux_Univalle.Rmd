---
title: 'SHELL: COMANDOS BASICOS DE LINUX'
author: "Diana Lopez and Andrea Gonzalez"
date: '`r Sys.Date()`'
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    theme: united
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

------

# Parte
Este módulo le permitirá al usuario llevar a cabo la ejecución de una serie de comandos, que son interpretados por un programa o shell. Linux dispone de varios de estos programas pero el más habitual es conocido como bash o Bourne Shell. 

Primeros pasos en Linux, **abrir una nueva Terminal**

```{r, engine='bash', eval=FALSE}
Ctrl + Alt + T
```

La terminal es muy sencilla y a la vez sumamente poderosa, te permite interactuar con el sistema operativo sin necesidad de una interfaz grafica.


## Comandos
En términos muy generales, los comandos en Linux se ejecutan con una sintaxis como la siguiente: **comando [opciones] argumento(s)**. Las opciones de un comando cambian el comportamiento del mismo y arrojan diferente información asociada al comando.
Dependiendo de la función del comando, se requerirá especificar parametros adicionales como archivos de entrada y salida, entre otros propios del comando.

***

## Consultando información. 

Cuando necesitamos conocer más acerca de un comando determinado o del uso del propio interprete y nos gustaria tener un manual, podemos disponer de un manual en línea muy útil denominado **man**. 

```{r, engine='bash', eval=FALSE}
##Su sintaxis basica es la siguiente: 
man [-fk] <comando>
```

```{r, engine='bash', eval=FALSE}
##Ejemplo:
man cp
```

Moverse con los cursores arriba o abajo y para salir pulsamos la letra **q**. La barra espaciadora pasa página a página y se puede usar Re Pag y Av Pag también para movernos.

***
## Listando archivos y directorios
Al ingresar en la Terminal, el directorio de trabajo actual es el directorio **home**. El **home** (simbolizado por ~) recibe el mismo nombre que el nombre de usuario, y es donde se guardan y almacenan los archivos personales y subdirectorios.

Para consultar la ruta completa al directorio de trabajo (o a cualquier directorio actual), se utiliza el comando **pwd** (print working directory)

```{r, engine='bash', eval=FALSE}
pwd
```

Para consultar que archivos y subdirectorios se encuentran en el directorio de trabajo (o cualquier directorio actual), se utiliza el comando **ls** (list)


```{r, engine='bash', eval=FALSE}
ls
```

Alternativamente, se puede usar el comando **ll**

```{r, engine='bash', eval=FALSE}
ll
```

Si no hay archivos o directorios actualmente visibles en el directorio de trabajo entonces la salida estara vacia. No obstante, el home por lo general no esta completamente vacío, ya que existen archivos ocultos (que comienzan con punto (.), que contienen información importante de configuración. Estos archivos no se deben eliminar ni modificar, sino por usuarios expertos. 

Para visualizar todos los archivos, incluyendo los ocultos

```{r, engine='bash', eval=FALSE}
ls -a
ll -a
```

![**Figura.** Listar **todos** los archivos en un directorio](ls_a.jpg)

NOTA: Para ver todas las opciones asociadas a los comandos **ls** y **ll**, ejecutar

```{r, engine='bash', eval=FALSE}
ls --help
ll --help
```

***
## Creando directorios
El comando **mkdir** (make directory) permite crear un directorio nuevo dentro de una ruta (por ejemplo, el home o cualquier otro directorio de trabajo actual). Para esta práctica, crearemos un directorio llamado "Practica".

```{r, engine='bash', eval=FALSE}
mkdir Practica
```

NOTA: En Linux, el uso de mayúsculas y minúsculas importa. No son equivalentes los directorios "Practica" que "practica" ni "PRACTICA". Tambien, se debe evitar el uso de espacios al nombrar archivos y directorios, en su lugar, se deben usar otros caracteres como (_) (,) (;) (.) para separar palabras. Por ejemplo, para nombrar un nuevo directorio, se puede usar "Practica_1" en lugar de "Practica 1", o "practica-curso-linux" y no "practica curso linux". Tampoco se deben usar caracteres como tildes.

***
## Cambiar de directorios
El comando **cd** (Change directory) permite cambiar de directorio, con el fin de moverse entre los directorios de trabajo, niveles arriba o niveles abajo. 

Para entender y facilitar moverse entre directorios en la Terminal, es importante primero revisar la estructura o jerarquia de los directorios en Linux. Dicha estructura se representa en forma de árbol:
 
![**Figura.** Estructura en forma de árbol de los directorios en Linux. La raíz del árbol **root** (simbolizado por /) es la base de toda la estructura de directorios y las ramas (directorios y archivos) surgen del root. Tomada de https://blog.desdelinux.net/estructura-de-directorios-en-linux/](arbol-directoriosLinux.png)  

Para consultar en detalle sobre los diferentes directorio en Linux, como / (root), /bin, /boot, /dev, /home, /lib, /usr, etc., referirse al siguiente link: http://www.linux-party.com/TutorialLinux/linux_files/jerarquia_sample.txt.

Aqui, cambiaremos de directorios al interior del home. Para esto, primero cambiaremos del home al directorio "Practica"" que creamos anteriormente

```{r, engine='bash', eval=FALSE}
cd Practica
pwd
ls
```


Con los comandos anteriores, cambiamos del home al directorio Practica, luego imprimimos la ruta a ese directorio actual y listamos el contenido. Vemos que aun esta vacío. 

Ahora, crearemos subdirectorios dentro de Practica

```{r, engine='bash', eval=FALSE}
mkdir Dir_1
mkdir Dir_2
ls
```

Luego, cambiaremos al directorio Dir_1, crearemos un subdirectorio dentro de este y accederemos al nuevo directorio creado
```{r, engine='bash', eval=FALSE}
#cd ./Dir_1
#pwd
#mkdir Dir_1.1
#ls
#cd Dir_1.1
#pwd

```

En resumen, hemos realizado lo siguiente :

![**Figura.** Creando directorios y cambiando de directorios](mkdir_cd.jpg) 
***

## Cambiando de directorios con . y ..

En Linux, utilizamos . y .. para denotar dos lugares relativos al directorio actual de trabajo. El primero hace referencia al directorio actual (.) y el segundo al directorio parental (..) o directorio inmediatamente anterior que contiene el directorio actual. Podemos visualizar estos directorios de la siguiente manera 

```{r, engine='bash', eval=FALSE}
ls -a 
```

![**Figura.** Listando directorios . y ..](ls_a2.jpg)

Estas dos sintaxis (. y ..) se utilizan para movernos tanto dentro del directorio actual como al inmediatamente anterior, de la siguiente manera

```{r, engine='bash', eval=FALSE}
pwd 
cd ..
pwd
cd ..
pwd
cd .
```

Con los comandos anteriores, subimos de niveles hasta regresar al directorio Practica, que contiene Dir_1 y Dir_1,1, que era donde nos ubicabamos inicialmente. 

El comando "cd ." significa "en el directorio actual".

***
## Visualizando la estructura en árbol de directorios en Linux 

Podemos visualizar la estructura en árbol de directorios que tenemos dentro de Practica utilizando el comando **tree**. Estando ubicados en el directorio Practica, ejecutamos el comando tree:

```{r, engine='bash', eval=FALSE}
tree
```

![**Figura.** Visualizando la estructura en arbol de directorios con **tree**](tree1.jpg)

Veamonos las estructuras en árbol de otros directorios de mayor nivel. Cambiemos al directorio home (~) y luego a / (root) y ejecutemos tree en cada uno.

```{r, engine='bash', eval=FALSE}
cd ~
#alternativamente, si ejecutamos cd sin ningun argumento, también nos cambia al directorio home
cd
pwd
tree
cd /
pwd
tree
```

***
## Rutas absolutas y rutas relativas

Una ruta o **PATH** es la ubicación única de un archivo o directorio al interior de un sistema de archivos. Es una combinación de / y caracteres alfa-numéricos.

Una **ruta absoluta** se define como la ruta de un archivo o directorio desde el directorio root (/). Por esta razón, es absoluta, ya que comienza desde la raíz del sistema de archivos. Por ejemplo, al ejecutar el comando **pwd** siempre nos arroja la ruta absoluta al directorio actual de trabajo, comenzando con (/).

Una **ruta relativa** se define como la ruta de un archivo o directorio relativo al directorio actual de trabajo. En este concepto, se utiliza entonces la sintaxis . y .. para navegar entre la estructura de directorios, siempre relativo al ultimo directorio de trabajo. Por tanto, estas rutas no comienzan con (/). 

Podemos cambiar inmediatamente a cualquier directorio dentro del sistema de archivos desde cualquier otro directorio usando una ruta absoluta, asi se encuentren lejos en la estructura del árbol de directorios. Por otro lado, la ruta relativa es útil para movernos entre niveles cercanos, ahorrando tiempo y facilitando la navegación, siempre y cuando se tenga presente cual es el directorio actual de trabajo y como se ubican los demas directorios relativo a este.

Ejemplos:

```{r, engine='bash', eval=FALSE}
pwd
#¿Donde estamos ubicados?
#Cambiemos al directorio Dir_1.1 con una ruta absoluta
cd /home/mobaxterm/Practica/Dir_1/Dir_1.1
pwd
#Cambiemos al directorio Practica con ruta relativa al directorio actual
cd ../..
pwd
#cambiemos a Dir_2 con ruta relativa al directorio actual
cd ./Dir_2
pwd
#Regresemos al directorio anterior especificando la ruta relativa y cambiemos de nuevo al Dir_2 utilizando la ruta absoluta
cd ..
cd /home/mobaxterm/Practica/Dir_2
```

![**Figura.** Cambiando de directorios usando rutas absolutas y relativas](rutaabs_rela.jpg)


-------

# Parte

## Creando y guardando archivos

1. Editores de texto: **nano**, **gedit**, **vim**

Existen diferentes editores de texto para crear archivos en Linux: nano, gedit y vim. **Gedit** es diseñado como un editor de textos de propósito general, y enfatiza la simplicidad y facilidad de uso. **vim** es el editor de texto más potente de Linux en modo consola, pero no es muy amigable al usuario por su cantidad de atajos de teclado para su manejo en consola. Por otro lado, **nano** es intermedio entre los dos anteriores. En esta práctica nos enfocaremos en el uso de **nano**.

**Nano** viene instalado por defecto en Ubuntu. Cualquier usuario por poco experimentado que sea es capaz de empezar a usar **Nano** desde el primer momento gracias a las dos líneas de ayuda que mantiene en su parte inferior.

Para abrir un archivo con el editor nano se debe escribir el comando seguido del nombre del archivo con su extensión correspondiente. Si el archivo no esta en la ruta o en el directorio actual, entonces se debe especificar la ruta al archivo. 

```{r, engine='bash', eval=FALSE}
#Crearemos un archivo nuevo llamado file.txt usando nano
nano file.txt
```

Para escribir, se debe ubicar en la línea y posición en que desea, utlizando las flechas del teclado, e insertar el texto. 

```{r, engine='bash', eval=FALSE}
#Ahora, abriremos y editaremos el archivo existente lista.txt usando nano
nano lista.txt
```

**Nano** esta pensado para ser usado con el teclado, no con el ratón, por lo que cuenta con diferentes acciones asociadas a combinaciones de teclas. Al presionar la primera vez cada combinación de teclas se activa cada opciones y al hacerla una vez más se desactiva. 

En la siguiente tabla podemos ver algunas de las más importantes:

![**Figura.** Acciones de teclado mas comunmente usadas en nano. Tomada de https://sliceoflinux.wordpress.com/2010/02/26/nano-sencillo-editor-de-textos-para-el-terminal/](nano_keys.jpg)

Un dato que siempre es útil en un editor de texto es saber en que línea se encuentra y a veces en que columna se va a editar un texto o valor. Para poder ver esta información puedes iniciar el editor **nano** con el parámetro -c, al hacerlo podrá ver en que línea y columna se encuentra conforme se desplace en el texto mediante las teclas de flechas.

```{r, engine='bash', eval=FALSE}
#Ahora, abriremos y editaremos el archivo existente lista.txt usando nano
nano -c lista.txt
```

Para pegar un texto previamente copiado de otra fuente, se usa la combinacion de teclas: **Ctrl+Shift+V**

Para grabar un archivo se usa la combinación de teclas: **Ctrl+o** (letra o). Presionar Enter, y listo.

Si no se desea grabar el archivo en ese momento, se puede cancelar esta accion con **Ctrl+c**

Alternativamente, para salir de **Nano**, se usa la siguiente combinación de teclas: **Ctrl+x** (y grabar el archivo si tiene alguna modificación) El editor permitirá verificar si desea guardar los cambios antes de salir. Debe responder Y (si) o N (no) y presionar Enter. Luego aparece una confirmación para conservar o cambiar el nombre del archivo. 

Para más informacion sobre combinaciones de teclados y opciones de uso, ver https://www.nano-editor.org/dist/v2.8/nano.html.

***

2. **cat**

Alternativamente, se puede usar el comando **cat** (concatenate) para crear archivos de listas sencillas, como se muestra a continuación:

```{r, engine='bash', eval=FALSE}
#Crearemos un archivo llamado lista.txt con el comando cat
cat > lista.txt
#Escribir los elementos de la lista a continuación
genoma
#Enter
transcriptoma
#Enter
proteoma
#Enter
metaboloma
#Enter
metagenoma
#Ctrl+C
ls
```

![**Figura.** Creando listas con el comando **cat**](cat_lista.jpg)
***

## Lectura de archivos

1. **cat**

El comando **cat** también permite visualizar el contenido de archivos. Por ejemplo, visualicemos el archivo lista.txt, creado anteriormente:

```{r, engine='bash', eval=FALSE}
cat lista.txt
```

![**Figura.** Creando listas con el comando **cat**](cat_verlista.jpg)

NOTA: Si el archivo tiene una extension de más de una página, este comando no será apropiado porque el contenido pasara de manera muy rápida por la pantalla hasta llegar a la última línea, como se podra observar con los siguientes archivo de ejemplo.

```{r, engine='bash', eval=FALSE}
cat example_table.tsvc
cat example.fasta
```


2. **less** y **more**

Para archivos de larga extensión, los comandos **less** y **more** permiten visualizar el contenido de archivos por página.

```{r, engine='bash', eval=FALSE}
less example_table.tsv
#Presione Enter para pasar a la siguiente línea. Presiona "b" para regresar a la página anterior. Escriba "q" para salir.
more example_table.tsv
#Presione Enter para pasar a la siguiente línea. Presione la barra de Espacio para ir a la siguiente pagina. Escriba "r" para ver todo el documento. Escriba "q" para salir.
#Visualice otro archivo de ejemplo.
less example.fasta
more example.fasta
```

El comando **less** tiene múltiples opciones para explorar un archivo. Por ejemplo, para regresar al comienzo del archivo se usa "g" y para ir al final se usa "G". Para más opciones, consultar https://www.lifewire.com/what-to-know-less-command-4051972. 


3. **head** y **tail**

Estos comandos imprimen las primeras (head) o últimas (tail) 10 líneas del archivo, de manera predeterminada. Si se desea visualizar una cantidad diferente de las primeras y últimas lieas, se utiliza la opcion **-n** antes del argumento. 

```{r, engine='bash', eval=FALSE}
head example_table.tsv
tail example_table.tsv
#Especifiquemos el parÃƒÂ¡metro -n para definir otro número de líneas a imprimir.
head -n 5 example_table.tsv
tail -n 5 example_table.tsv
```

***

## Búsquedas dentro de archivos

1. **wc**

El comando **wc** (word count) permite contar las palabras, caracteres y líneas en un archivo.  

```{r, engine='bash', eval=FALSE}
wc --h
wc example_table.tsv
wc -l example_table.tsv
wc -w example_table.tsv
#Contemos las líneas en otro archivo de ejemplo.
wc -l example.fasta
```

2. **less**

Además de permitir visualizar el contenido de un archivo, **less** permite hacer búsquedas de contenidos especificos dentro del archivo, de la siguiente manera:

```{r, engine='bash', eval=FALSE}
less example_table.tsv
#Escribir / y luego el tÃƒÂ©rmino a buscar
/ Howard
```


3. **grep**

Este comando es uno de los muchos que vienen predeterminados en Linux. Es poderoso para realizar búsquedas de palabras o patrones en archivos, donde el resultado impreso es la línea completa que contiene ese término de búsqueda. 

```{r, engine='bash', eval=FALSE}
grep --h
grep "Howard" example_table.tsv
#Miremos si la búsqueda es sensible a mayúsculas y minúsculas
grep "howard" example_table.tsv
#Contemos el número de líneas que contienen el término de búsqueda
grep -c "Howard" example_table.tsv
#Especifiquemos que imprima el número de la la línea donde encuentra el término de búsqueda
grep -n "Howard" example_table.tsv
#Especifiquemos que imprima las líneas que NO contienen el término de búsqueda (invertido)
grep -v "Howard" example_table.tsv
```

![**Figura.** Busqueda de palabras o patrones en un archivo usando **grep**](grep_howard.jpg)

Ahora, realicemos una búsqueda para varios términos simultáneamente, que estan contenidos en una lista.

```{r, engine='bash', eval=FALSE}
#Creemos la lista de términos a buscar
cat > lista_grep.txt
Howard
Jones
Andrews
Thompson
#Ctrl+C
cat lista_grep.txt
#Busquemos los términos
fgrep -f lista_grep.txt example_table.tsv
```

![**Figura.** Búsqueda de palabras o patrones a partir de una lista usando **grep**](frep_list.jpg)

Ahora, aprendamos a redireccionar salidas, de tal manera que los resultados no se impriman en la Terminal, sino que se guarden en un archivo.

```{r, engine='bash', eval=FALSE}
#Redireccionemos la salida de grep a un archivo nuevo
grep "Howard" example_table.tsv > search_results_table.tsv
less search_results_table.tsv
#Busquemos otro término y redireccionemoslo al mismo archivo anterior
grep "Jones" example_table.tsv > search_results_table.tsv
less search_results_table.tsv
#¿Qué paso con los resultados de la primera búsqueda?
#Para no sobreescribir, sino adicionar contenido a un archivo utilizamos ">>"
grep "Howard" example_table.tsv >> search_results_table.tsv
less search_results_table.tsv
```


***

## Manipulación de archivos y directorios

1. Copiando con **cp**

El comando **cp** (copy) permite copiar archivos y directorios.

```{r, engine='bash', eval=FALSE}
#Realicemos una copia del archivo lista.txt y llamemosla lista_2.txt
cp lista.txt lista_2.txt
less lista.txt
less lista_2.txt
ls
#Veamos que otra información sobre estos archivos nos sale especificando el comando ll
ll
ll -h
#Realicemos una copia del directorio Dir_1 con todo su contenido y llamemoslo Dir_1-copia. Para esto, necesitamos especificar la opcion "-r" que significa copia recursiva
cp -r Dir_1/ Dir_1-copia
ll
cd Dir_1-copia
ll
#Copiemos el directorio Dir_1.1 al directorio Dir_2 que estÃƒÂ¡ en Practica, un nivel más arriba de donde nos encontramos actualmente
cp -r Dir_1.1/ ../Dir_2/
cd ../Dir_2
ll
```

En resumen, hemos realizado lo siguiente, como se muestra en el pantallazo a continuación:

![**Figura.** Copiando archivos y directorios usando **cp**](cp_dir.jpg)
![**Figura.** Continuación: Copiando archivos y directorios usando **cp**](cp_dir2.jpg) 


2. Moviendo y renombrando con **mv**

El comando **mv** (move) permite mover archivos y directorios.

```{r, engine='bash', eval=FALSE}
#Regresemos al directorio Practica
cd ..
#Movamos el archivo lista.txt al directorio Dir_2
mv lista.txt ./Dir_2
cd ./Dir_2
ls
#Renombremos el archivo lista.txt a listado.txt
mv lista.txt listado.txt
ls
#Note que si no especifica una ruta como argumento, entonces mv servirá para renombrar el archivo
#Movamos el directorio Dir_1.1 al directorio Practica, un nivel más arriba de donde nos encontramos actualmente
mv Dir_1.1/ ../
cd ..
ll
#Renombremos el directorio Dir_1.1 a Dir_nuevo
mv Dir_1.1/ Dir_nuevo
ll
```

En resumen, hemos realizado lo siguiente, como se muestra en el pantallazo a continuación:

![**Figura.** Moviendo y renombrando archivos y directorios usando **mv**](mv_dir.jpg)

![**Figura.** Continuación: Moviendo y renombrando archivos y directorios usando **mv**](mv_dir2.jpg)

3. Eliminando con **rm** y **rmdir**

El comando **rm** (remove) permite eliminar definitivamente un archivo o directorio, y el comando **rmdir** permite eliminar definitivamente un directorio, siempre y cuando este vacío. Se debe tener MUCHO CUIDADO al usar estos comandos, ya que un archivo o directorio eliminado en Linux NO se puede recuperar.

```{r, engine='bash', eval=FALSE}
#Eliminemos el directorio Dir_nuevo, primer revisemos si esta vacío
ll Dir_nuevo
rmdir Dir_nuevo
ls 
#Eliminemos el directorio Dir_1-copia, primero revisemos si esta vacío
ll Dir_1-copia
#Como no esta vacío, entonces utilicermos el comando rm con las opciones -f (forzar u obligar) y -r (recursivo). Estas permitiran obligar a borrar el directorio aunque no esta vacío y recursivamente borrar el contenido que hay dentro
rm -rf Dir_1-copia
ls
#Eliminemos recursivamente los archivos lista_2.txt y lista_grep.txt
rm -r lista_2.txt lista_grep.txt
ls
```

En resumen, hemos realizado lo siguiente, como se muestra en el pantallazo a continuación:

![**Figura.** Eliminando archivos y directorios usando **rm**](rm.jpg)


4. Extrayendo y manipulando contenidos con **cut**, **sort**, **paste**

Los comandos **cut**, **sort** y **paste** permiten manipular archivos en donde la información esta separada por columnas (tablas), tal como el archivo de ejemplo example_table.tsv. Estos son muy utiles para extraer subcontenidos de informaciónn y reorganizarla en nuevos archivos. **Cut** permite cortar columnas de un archivo, **Paste** permite pegar columnas, y **sort** permite reordenar la información de una columna en orden numérico o alfabético dependiendo del carácter. 

Aqui, trabajaremos con el archivo example_table.tsv.

```{r, engine='bash', eval=FALSE}
#Volvamos a visualizar el archivo example_table.tsv
less example_table.tsv
#Por la extensión del archivo (.tsv) sabemos que el delimitador entre columnas es un tabulador, ya que esta extensión significa Tab Separated Values (Valores separados por tabulación). Conocer el delimitador es importante para que el comando cut funcione correctamente sobre el archivo. El delimitador por defecto es el tabulador. Otros delimitadores posibles son coma, punto, punto y coma, espacio, etc. Estos se deben especificar con la opcion -d. Por ejemplo, -d ".", -d ",", -d ";", -d " ". Si desearamos especificar el tabulador, seria -d "\t"
#Vamos a extraer la información contenida en las columnas OrderDate, Item y TotalM usando cut. Estas columnas corresponden a la col1, col4 y col7, respectivamente. El valor de las columnas se especifica con la opcion -f, por ejemplo, -f 1, -f 4, -f 7. 
cut -f 1 example_table.tsv > OrderDate.txt 
cut -f 4 example_table.tsv > Item.txt
cut -f 7 example_table.tsv > TotalM.txt
less OrderDate.txt
less Item.txt
less TotalM.txt
#Ahora, pegaremos estas columnas en un nuevo archivo llamado new_table.csv, usando el comando paste. Debemos especificar el delimitador que deseamos, por defecto se usa el tabulador, pero si deseamos otro, se debe especificar de la misma manera que lo descrito para el comando cut. Aqui, pegaremos las columnas con el delimitador coma (,) por lo cual le hemos dado la extensión .csv a la nueva tabla (comma separated values). Pegamos las columnas en el orden que deseamos que aparezcan en la nueva tabla
paste -d "," OrderDate.txt Item.txt TotalM.txt > new_table.csv
less new_table.csv
#Alternativamente, para ahorrar tiempo, se pueden cortar las tres columnas a la vez y redireccionarlas a una tabla nueva, sin necesidad de usar paste, no obstante, el delimitador será un tabulador por defecto
cut -f 1,4,6 example_table.tsv > new_table.tsv
less new_table.tsv
#Ahora, usemos el comando sort para reordenar la tabla de acuerdo con la columna TotalM, que contiene valores numericos.
sort -k 3 -g new_table.tsv > sort_new_table.tsv
less sort_new_table.tsv
#Esta vez ordenemos la tabla de acuerdo con el Item, que contiene valores alfabéticos.
sort -k 2 -d sort_new_table.tsv > resorted_new_table.tsv
less resorted_new_table.tsv
```


5. Concatenando con **cat**

Entre otras funciones del comando **cat**, se encuentra la de concatenar contenidos de listas, una debajo de otra; por eso su nombre concatenate. Aqui, concatenaremos columnas y lo contrastaremos con lo obtenido con el comando paste.

```{r, engine='bash', eval=FALSE}
#Retomemos las columnas extraidas en OrderDate.txt, Item.txt y TotalM.txt, y concatenemoslas con cat
cat OrderDate.txt Item.txt TotalM.txt > cat_table.txt
less cat_table.txt
```


## Pipes
En Linux, resulta dispendioso escribir un comando tras otro en la Terminal para realizar una tarea. Para ahorrar tiempo y esfuerzo de trabajo, los **pipes** se utilizan para conectar comandos y sus salidas de tal forma que se pueda ejecutar una tarea con una sola línea de comando. Para demostrar esto, retomaremos primero el ejemplo de los comandos **cut** y **sort**, usando un pipe (|).

```{r, engine='bash', eval=FALSE}
cut -f 1,4,7 example_table.tsv | sort -k 3 -g > sort_new_table.tsv
less sort_new_table.tsv
```

Ahora, retomemos el ejemplo del comando sed, usando un pipe.


## Comodines
Otra utilidad que ahorra tiempo y esfuerzo de escritura en la línea de comandos son los comodines "*" y "?".

El * es un carácter que simboliza "cualquier otros carácteres" y permite llamar a varios archivos o directorios que comparten un mismo nombre o parte de el. Por ejemplo,

```{r, engine='bash', eval=FALSE}
ls *tsv
#Imprime en pantalla todos los archivos terminados en tsv, independiente de su nombre raiz.Por el contrario, si especificaramos tsv*, imprimiria todos los archivos que comienzan por tsv y terminan en cualquier otra cosa, si existieran.
```

El **?** es un carácter que simboliza "cualquier otro carácter", es decir, reemplaza un solo carácter, cualquiera que sea. Asi, si escribimos ?asa, podrá encontrar coincidencias con palabras como casa, masa, pero no brasa.

El comodin "*" es muy útil por ejemplo para mover o copiar múltiples archivos a la vez, ahorrando el tiempo de ejecutar un comando para cada uno. Por ejemplo, deseamos mover 100 archivos con extensión .fasta a un nuevo directorio, entonces ejecutariamos:

mv *.fasta ./Dir_nuevo


-------

# Parte

## Comandos de proceso

1. **ps**

Muestra los procesos que se encuentran activos en el sistema actualmente. Este comando es muy útil para saber que comandos están funcionando en un determinado momento. Algunos ejemplos de su uso

```{r, engine='bash', eval=FALSE}
# Para ver todos sus procesos que estan asociados a algún terminal.
ps 
```

![**Figura.**Procesos activos en el sistema](ps.png)
```{r, engine='bash', eval=FALSE}
# Para ver todos sus procesos y los de otros usuarios siempre asociados a algún terminal.
ps a

# Para ver todos sus procesos estan asociados o no a algún terminal.
ps x
```

+ PID Es el valor numérico que idenfica al proceso.
+ TTY Es el terminal asociado a ese proceso. Los demonios del sistema no tienen ningún terminal asociado y en este campo figuraria un ?
+ STAT Tiene tres campos que indican el estado del proceso (R,S,D,T,Z) (W) (N) La S indica que el proceso esta suspendido esperando la liberacion de un recurso (CPU, Entrada Salida, etc) necesario para continuar.
+ TIME Indica el tiempo de CPU que lleva consumido ese proceso desde que fue arrancado.
+ COMMAND Muestra el comando y los argumentos que le fueron comunicados.


2. **top**

Muestra todos los procesos en funcionamiento. En un sistema multitarea no se debe usar el término programa para hablar de la ejecución del mismo. En su lugar hablaremos de proceso indicando con ello que esta arrancado y funcionando. Un programa puede dar lugar a varios procesos.

![**Figura.**Procesos en funcionamiento](top.png)

- **PID y PPID**: A cada proceso le correspondería un número PID que le identifica totalmente. Es decir en un mismo momento es imposible que existan dos procesos con el mismo PID. Lo mismo que todos los procesos tienen un atributo PID que es el número de proceso que lo identifica en el sistema tambien existe un atributo llamado PPID. Este numero se corresponde con el número PID del proceso padre.

- **UID y EUID**: Los procesos tienen un EUID (Efectiv User Identif), y un UID normalmente ambos coinciden. El UID es el identificador de usuario real que coincide con el identificador del usuario que arranca el proceso. El EUID es el identificador de usuario efectivo y se llama así, porque es el identinficador que se tiene en cuenta a la hora de considerar los permisos que luego explicaremos. El UID es uno de los atributos de un proceso que indica por decirlo de alguna manera quien es el propietario actual de ese proceso y en función de ello podría hacer ciertas cosas. Por ejemplo, si un usuario normal intentará eliminar un proceso del cual no es propietario el sistema no lo permitirá mostrando un mensaje de error en el que advierta que usted no es el propietario de ese proceso y por tanto no está autorizado a hacer esa operación.

```{r, engine='bash', eval=FALSE}
## Comprobaremos cual es el UID de su directorio home.
# Cambiamos el directorio actual a home
cd
# Comprobamos a quien pertenece 'uid' y 'guid'
ls -ld .
# Ahora obtenemos el 'uid' y el 'gid' con sus valores numericos.
ls -lnd .
```

![**Figura.** UID y GUID](ls_top.png)

3. **kill**

Detiene el proceso asignado al pid que muestra la salida del comando ps. En realidad envia senales a otros procesos, pero la acción por defecto asociada a la mayoría de las señales de unix es la de finalizar el proceso.

```{r, engine='bash', eval=FALSE}
##kill "pid" (process id)
##Por ejemplo, si se quisiera matar el proceso 6548 ejecutamos:
kill 6548
##Podemos volver a correr el comando ps y observar que ya este proceso no se encuentra activo
```

**'kill'** por defecto es **'kill -15'** envia un SIGTERM y generalmente provoca cierre ordenado de los recursos en uso. Esta señal puede ser ignorada, o puede ser utilizada como un aviso para terminar ordenadamente. Para matar un proceso resulta recomendable enviar primero un kill -15 y si no se consigue nada repetir con **kill -9**. Este último **-9** envia SIGKILL que no puede ser ignorada, y termina inmediatamente. Solo fallará si no tenemos permisos para matar ese proceso.

4. **bg**

Muestra todos los procesos pausados o en segundo plano (recordamos que Ctrl + z establece procesos en segundo plano).

Para ejecutar un programa en background, basta con poner el signo ampersand (&) al término de la línea de comandos. 

```{r, engine='bash', eval=FALSE}
##Por ejemplo, si se quisiera copiar el archivo report.txt que esta dentro de la carpeta ecoli a la carpeta ejercicio
cp ~/ecoli/report.txt ~/ejercicio/ &
```

 ![**Figura.** Comandos en background](cp_bg.png)
 
 Cuando ha terminado la ejecución del programa, el sistema lo reporta mediante un mensaje **Done**

Si se hubiese ejecutado el programa y no se hubiese puesto el ampersand, se podría pasarlo a background de la siguiente manera:

1. Se suspende la ejecucion del programa, pulsando Ctrl+Z.

2. Se ejecutamos la siguiente orden: bg


4. **fg**

Trae de vuelta el proceso mas reciente puesto en segundo plano.


## Atajos de teclado

**Shift (Mayus) + RePag**: Realizaremos scroll hacia arriba en la terminal.

**Shift (Mayus) + AvPag**: Realizaremos scroll hacia abajo en la terminal.

**Tab (Tabulador)**: Completara el comando, nombre de fichero o directorio que estemos escribiendo. En caso de multiples coincidencias, con una doble pulsacion de esta tecla obtendremos todos los resultados posibles encontrados en el directorio o sistema.

**Flecha de direccion 'arriba' y /o 'abajo'**: Nos moveremos por el historial compuesto por los últimos comandos usados.

**Ctrl + r**: Buscará en el historial el último comando usado según lo que vayamos escribiendo. Por ejemplo utilizamos el comando **clear** hace unas horas, si pulsamos Ctrl + r y escribimos **cl** nos mostrará el comando clear, puesto que lo ha buscado en el historial y es el más reciente que coincide.

**Ctrl + c**: Interrumpe cualquier proceso en ejecución de forma inmediata y nos devuelve al prompt.

**Ctrl + z**: Envia el proceso actual a segundo plano. Para recuperarlo solo tendremos que escribir **fg** y pulsar Intro.

**Ctrl + d**: Cierra la sesión de la terminal en la que nos encontramos. Si estamos usando una interfaz gráfica en la que hemos abierto una terminal, esta sólo se cerrará.

**Ctrl + w**: Elimina la palabra anterior a la posición del cursor.

**Ctrl + k**: Corta todo aquello que se encuentra entre la situación del cursor y el final de la línea.

**Ctrl + u**: Corta la línea en la que nos encontramos al completo.

**Ctrl + y**: Pega el contenido copiado o cortado con Ctrl + u o Ctrl + k.

**!!**: Repetirá el último comando usado.


## ¿Cuánto ocupa toda la información? 

Este comando contabiliza el espacio que ocupa en disco un fichero o un directorio con todos sus subdirectorios.
```{r, engine='bash', eval=FALSE}
##Su sintaxis basica es la siguiente: 
du [opciones] [ficheros...] 
```

Algunas de las opciones: 

-a, muestra ademas el espacio que ocupa cada uno de los ficheros que hay en los directorios que le indiquemos. 

![**Figura.** Ejemplo de la ejecución del comando du.](du_a.png)

-s, que informa solamente del directorio que le hayamos indicado sin contar sus subdirectorios.

-h, lo pone en términos de lectura para humanos, muestra el tamaño en Gb. 

![**Figura.** Ejemplo de la ejecución del comando du.](du.png)

------

# Parte

## Programación shell

La programación es una de las herramientas más apreciadas por todos los administradores y muchos usuarios de Linux/Unix ya que permite automatizar tareas complejas, comandos repetitivos y ejecutarlas con un solo llamado al script o hacerlo automaticamente a horas escogidas sin intervención de personas.

Estos scripts pueden usar un sin número de herramientas como

+ Comandos del sistema Linux/Unix (ejm: ls, cut)
+ Funciones intrinsecas del shell (ejm: kill, nice)
+ Lenguaje de programación del shell (ejm: if/then/else/fi)
+ Programas y/o lenguajes de procesamiento en línea. (ejm: awk, sed, Perl)
+ Programas propios del usuario escritos en cualquier lenguaje.


Un primer acercamiento para agrupar comandos puede ser por medio del carácter **;**. Por

```{r, engine='bash', eval=FALSE}
##ejemplo, tecleando el comando:
$ date; ls 
## Se ejecutará sucesivamente los comandos date y ls
```

También podría crearse un script con un editor de textos que contenga los comandos. Los Scripts son archivos con extensión *.sh* que se ejecutan en terminal (bash o sh).

Todos los scripts deben empezar con un conjunto de carácteres conocido como sha bang y que es: **#!/bin/bash** o **#!/bin/sh**

```{r, engine='bash', eval=FALSE}
## abrir un editor de texto
$ nano
## se abre nano y se escriben lo sgte:

#!/bin/sh
date
ls

## Presionamos ctrl + X para salir de nano y le decimos que si guarde y ponemos un nombre, por ejemplo primer_programa.sh
```

Antes de ejecutar un script se deberá asignar permisos de ejecución: _chmod +x nombredelscript.sh_
Para ejecutar un script no hay más que teclear en la terminal: *./nombredelscript*, ver figura

Si no estuvieramos en terminal bash tecleariamos entonces: *sh ./nombredelscript*

![**Figura.** Ejecutando el primer_programa.sh](nano.png)

```{r, engine='bash', eval=FALSE}
## Ejemplo HolaMundo.sh
## Se abre nano y se escriben lo sgte:

#!/bin/bash
clear
echo "Hola mundo ,este es mi primer script"

## Presionamos ctrl + X para salir de nano y le decimos que si guarde y ponemos un nombre, HolaMundo.sh
```

```{r, engine='bash', eval=FALSE}
## Ejemplo ScriptUno.sh
## Se abre nano y se escriben lo sgte:

#!/bin/bash
clear
nombre="Pepito"
apellidos="Perez"
echo "Te llamas $nombre $apellidos"

## Presionamos ctrl + X para salir de nano y le decimos que si guarde y ponemos un nombre, ScriptUno.sh
```

```{r, engine='bash', eval=FALSE}
## Ejemplo Fecha.sh
## Se abre nano y se escriben lo sgte:

#!/bin/bash
clear
fecha=`date | cut -d " " -f 1,2,3`
hora=`date | cut -d " " -f 4`
echo "Hoy es $fecha y son las $hora"

## Presionamos ctrl + X para salir de nano y le decimos que si guarde y ponemos un nombre, ScriptUno.sh
```

```{r, engine='bash', eval=FALSE}
## Ejemplo OtroScript.sh
## Se abre nano y se escriben lo sgte:

#!/bin/bash
clear
# IFS es una variable de entorno que determina el delimitador de campos
# (que por defecto vale " "),en este script queremos cambiarlo a "," para escribir por teclado nombre,apellidos
IFS=","
read -p "Introduce el nombre,apellidos:" nombre apellidos
echo "El nombre es $nombre y los apellidos son $apellidos"

## Presionamos ctrl + X para salir de nano y le decimos que si guarde y ponemos un nombre, OtroScript.sh
```

***

### Estructuras condicionales

Los comandos más utilizados en la creación de scripts son:

- *if* equivale a un "si".La sintaxis es if condición Es necesario cerrarlo con un *fi*
- *else*
- *elif* equivale a un *else+if*. No es necesario cerrarlo
- *case* se utiliza cuando queremos reflejar varios casos de operación en nuestro script. Es necesario cerrarlo con un *esac*.
- *while* equivale a un "mientras que",y sirve para indicarle al script,por ejemplo,cuando debe dejar de ejecutarse,o cuando cambiar el tipo de ejecucion
- *do;done*

La estructura básica de una condición seria:

*if* condición
    *then*
        comando1
        ...
        ...
*else*
        comando1
        ...
        ...
*fi*

```{r, engine='bash', eval=FALSE}
## Ejemplo CompruebaDirectorio.sh
## Se abre nano y se escriben lo sgte:

#! /bin/bash
clear
if `cd /home/mobaxterm/ecoli/`
then
echo "Pues si, es un directorio y contiene."
ls -l
else
echo "Pues va a ser que no es un directorio"
fi

## Presionamos ctrl + X para salir de nano y le decimos que si guarde y ponemos un nombre, CompruebaDirectorio.sh
```


--------

# Parte 

## Práctica Correr un BLAST en local


Porque es interesante correr BLAST de forma local

1. Porque puede ser corrido en datos propios.

2. Porque puede ser integrado directamente a los análisis subsecuentes, y hacer parte de un mismo programa.

3. Representa mayor velocidad, al no quedar en colas dentro del servidor del NCBI.



*A continuación correremos un BLAST con los datos de secuencias ambientales*


1. Cree un nuevo directorio llamado blast:
```{r, engine='bash', eval=FALSE}
## Desde su home:
mkdir blast
cd blast
```

![**Figura.** Creación de directorio blast](mkdirblast.png)

2. Copie el archivo MyQuery.fasta y rep_set.fasta de la carpeta datos, al directorio blast

3. Observe en el archivo, ¿Qué tipo de secuencias son? (nuclétidos o  proteinas)

```{r, engine='bash', eval=FALSE}
more MyQuery.fasta
more rep_set.fasta
```	

4. ¿Cuántas secuencias hay en cada archivo?

```{r, engine='bash', eval=FALSE}
grep -c '>' MyQuery.fasta
grep -c '>' rep_set.fasta
```	

5. Cree la base de datos a partir del archivo rep_set.fasta

```{r, engine='bash', eval=FALSE}
# Desde la carpeta de blast ejecutar:

../ncbi-blast-2.6.0+/bin/makeblastdb.exe -in rep_set.fasta -dbtype nucl -out My16sAmplicon

```


6. Corra un BLAST con el archivo MyQuery.fasta como "blanco" , contra la base de datos creada. Obtenga un archivo tabular.

```{r, engine='bash', eval=FALSE}
# Desde la carpeta de blast ejecutar:
../ncbi-blast-2.6.0+/bin/blastn.exe -query MyQuery.fasta -task blastn -db My16sAmplicon -outfmt 6 -out blast_salida &
```

      
7. Mire el estatus de su proceso:

```{r, engine='bash', eval=FALSE}
# Verifique con el sgte comando:
ps
```

8. cuando el trabajo termine, mire los archivos en el directorio:

```{r, engine='bash', eval=FALSE}
# Verifique con el sgte comando:
ls
```	

*Mire las cincuenta primeras líneas del resultado*

```{r, engine='bash', eval=FALSE}
#verifique con el sgte comando:
head -50 blast_salida
```	

Las columnas corresponden a:

+ 1. query id

+ 2. subject id 

+ 3. porcentaje de identidad

+ 4. longitud del alíneamiento

+ 5. número de "mismatches" 

+ 6. número de "gaps" abiertos 

+ 7. posición de inicio del "query"

+ 8. posición de final del "query"

+ 9. posición de inicio del blanco 

+ 10. posición de final de blanco 

+ 11. e-value 

+ 12. puntaje del alineamiento



9. ¿Cuántas secuencias tienen homología con la base de datos?
```{r, engine='bash', eval=FALSE}
#verifique con el sgte comando:
cut -f1 blast_salida | uniq | grep -c '^'
```	
	
10. ¿Cuántas secuencias tienen alta homología (E-value < 0.05) y al menos 90% de identidad?
```{r, engine='bash', eval=FALSE}
#verifique con el sgte comando:
awk -F "\t" '{if ($3>90 && $11<0.05) print $1}' blast_salida | uniq | grep -c '^' 
```	


11. ¿Cuntas secuencias tienen alta homología (E-value <1e-50) con un mínimo de 100 nucléoticos alineados?

```{r, engine='bash', eval=FALSE}
#verifique con el sgte comando:
awk -F "\t" '{if ($4>100 && $11<0.05) print $1}' blast_salida | uniq 
```	
  

*Guarde el resultado en un archivo*

```{r, engine='bash', eval=FALSE}
# Verifique con el sgte comando:
awk -F "\t" '{if ($4>100 && $11<0.05) print $1}' blast_salida > resultados_filtrados
```

